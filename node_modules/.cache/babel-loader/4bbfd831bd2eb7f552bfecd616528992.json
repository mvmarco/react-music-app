{"ast":null,"code":"var _jsxFileName = \"/home/mvmarco/code/mvmarco/react-music-app/src/components/Player.js\";\n\n/*   \n  \"useRef\" is a way of connecting to the elements without doing: document.querySelector(\"audio\")\n  it is a way to grab something using react.\n  So you can create a const with a null initial value, as below:\n  const audioRef = useRef(null)\n  then we pass it as a prop in our <audio> element\n\n  The event callback, use audioRef.current (which is one of the key of the audio object) and\n  calls a pre-existing function on audio called play();\n  audioRef.current.play();\n */\n// ####################################\n// ERROR: CONTROLLED AND UNCONTROLLED\n// ####################################\n\n/* \n  error: a component is changing an uncontrolled input of index.js type range to be controlled.\n  Input elements should not switch from uncontrolled to controlled (or vice versa).\n   Uncontrolled means that our input value is not associated to a state, so when the data changes\n  associated to a state the input is still asociated to the input itself and not the react state \n  input. Once you associate the input value to the state, the component becomes controlled.\n   1. uncontrolled component: input that has nothing to do with a state\n  2. controlled component: value of the input is associated to  \n   we got the error because, that mess up with the states:\n  currentTime: 0,\n  duration: 0,\n   was set to null:\n  currentTime: null,\n  duration: null,\n*/\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faPlay, faAngleLeft, faAngleRight, faPause } from '@fortawesome/free-solid-svg-icons';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst Player = ({\n  isPlaying,\n  setisPlaying,\n  audioRef,\n  setsongInfo,\n  songInfo,\n  songs,\n  currentSong,\n  setcurrentSong,\n  setSongs\n}) => {\n  // Ref,  it is moved to App. so we can use it to LibrarySong.js when you click the song there, it plays\n  // const audioRef = useRef(null);\n  // state I am gonna use only here: timing, moved to the app\n\n  /*\n    const [songInfo, setsongInfo] = useState({\n      currentTime: 0,\n      duration: 0,\n    });\n   */\n\n  /*\n    // REMOVED IT BECAUSE IT IS DOUBLE ON THE LIBRARYSONG\n    // UseEffect\n    // when you skip song also the library song gets updated\n    useEffect(() => {\n      const newSongs = songs.map((song) => {\n        if (currentSong.id === song.id) {\n          return {\n            ...song,\n            active: true,\n          };\n        } else {\n          return {\n            ...song,\n            active: false,\n          };\n        }\n      });\n      setSongs(newSongs);\n    }, [currentSong]);\n    // run this function all the time the current song is updated.\n    // basically when the current song changes, the status is active, and active status = hover LibrarySong\n  */\n  const activeLibraryHandler = nextPrev => {\n    const newSongs = songs.map(song => {\n      if (currentSong.id === nextPrev.id) {\n        return { ...song,\n          active: true\n        };\n      } else {\n        return { ...song,\n          active: false\n        };\n      }\n    });\n    setSongs(newSongs);\n  }; // Event Handlers\n\n\n  const playSongHandler = () => {\n    console.log(audioRef);\n\n    if (isPlaying) {\n      audioRef.current.pause();\n      setisPlaying(!isPlaying);\n    } else {\n      audioRef.current.play();\n      setisPlaying(!isPlaying);\n    }\n  }; // this is connected to the onTimeUpdate event. Which let us update values in real time\n  // this is connected to onLoadedMetadata, when the pages loads the info updated\n  // moved to the App\n\n  /*   const timeUpdateHandler = (e) => {\n    // from this event we can extract: the current time we are in the song and also the song duration\n    console.log(e);\n    const currentTime = e.target.currentTime;\n    const duration = e.target.duration;\n    console.log(currentTime, duration);\n    setsongInfo({...songInfo, currentTime: currentTime, duration: duration })\n  } */\n  // onChange is the event for this callback to move the input range\n\n\n  const dragHandler = e => {\n    audioRef.current.currentTime = e.target.value;\n    console.log(e.target.value);\n    setsongInfo({ ...songInfo,\n      currentTime: e.target.value\n    });\n  }; // function for formatting the time, using a stackOverflow formatting\n\n\n  function formatTime(time) {\n    return Math.floor(time / 60) + \":\" + (\"0\" + Math.floor(time % 60)).slice(-2);\n  }\n\n  const skipTrackHandler = async direction => {\n    // get the index of the current song\n    let currentIndex = songs.findIndex(song => song.id === currentSong.id); // if the class is equal to skip-forward the change the current song, using index +1\n    // but to prevent the last song to skip to nothing we need to add the \"modules\" %\n    // if 8 % 8 is equal to 0, 0 will be our index, so it starts again from the beginning\n\n    /* \n      if 2 % 8 is equal to 2, 2 will be the index. \n      It's really supper easy to figure out the results of modulo when the first number is smaller. \n      The result is always equal the the first (smaller) number.\n      Because the second number is larger, it 'goes into' the first number zero times and the remainder \n      is the entirety of this first number.\n       if you wanna go back, and the index is 0 you cannot go index -1. Because index -1 does not exist.\n      so we need to make a ternary where if the current index is 0 you take the song.length -1\n      and get index 7. If you are not at current index 9 you can just go back currentIndex - 1\n      we need to return it either one of the two ifs and update the \n     */\n\n    if (direction === \"skip-forward\") {\n      await setcurrentSong(songs[(currentIndex + 1) % songs.length]);\n      activeLibraryHandler(songs[(currentIndex + 1) % songs.length]);\n    } else if (direction === \"skip-back\") {\n      await setcurrentSong(songs[currentIndex - 1] || songs[songs.length - 1]);\n      activeLibraryHandler(songs[currentIndex - 1] || songs[songs.length - 1]);\n    } // this line waits for the songs to load before we can actually play them\n\n\n    if (isPlaying) {\n      audioRef.current.play();\n    }\n  }; // const trackAnim = {\n  //   transform: `translateX(${songInfo.animationPertantage}%)`,\n  // };\n\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"player-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"time-control\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: formatTime(songInfo.currentTime)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 181,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          background: `linear-gradient(to right, ${currentSong.color[0]},${currentSong.color[1]})`\n        },\n        className: \"track\",\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"range\",\n          value: songInfo.currentTime,\n          min: 0,\n          max: songInfo.duration || 0,\n          onChange: dragHandler\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 188,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"animate-track\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 195,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 182,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: songInfo.duration ? formatTime(songInfo.duration) : \"0:00\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 197,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 180,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"player-control\",\n      children: [/*#__PURE__*/_jsxDEV(FontAwesomeIcon, {\n        onClick: () => skipTrackHandler(\"skip-back\"),\n        className: \"skip-back\",\n        size: \"2x\",\n        icon: faAngleLeft\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 201,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(FontAwesomeIcon, {\n        onClick: playSongHandler,\n        className: \"play\",\n        size: \"2x\",\n        icon: isPlaying ? faPause : faPlay\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 207,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(FontAwesomeIcon, {\n        onClick: () => skipTrackHandler(\"skip-forward\"),\n        className: \"skip-forward\",\n        size: \"2x\",\n        icon: faAngleRight\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 213,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 179,\n    columnNumber: 5\n  }, this);\n};\n\n_c = Player;\nexport default Player;\n\nvar _c;\n\n$RefreshReg$(_c, \"Player\");","map":{"version":3,"sources":["/home/mvmarco/code/mvmarco/react-music-app/src/components/Player.js"],"names":["FontAwesomeIcon","faPlay","faAngleLeft","faAngleRight","faPause","Player","isPlaying","setisPlaying","audioRef","setsongInfo","songInfo","songs","currentSong","setcurrentSong","setSongs","activeLibraryHandler","nextPrev","newSongs","map","song","id","active","playSongHandler","console","log","current","pause","play","dragHandler","e","currentTime","target","value","formatTime","time","Math","floor","slice","skipTrackHandler","direction","currentIndex","findIndex","length","background","color","duration"],"mappings":"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","sourcesContent":["/*   \n  \"useRef\" is a way of connecting to the elements without doing: document.querySelector(\"audio\")\n  it is a way to grab something using react.\n  So you can create a const with a null initial value, as below:\n  const audioRef = useRef(null)\n  then we pass it as a prop in our <audio> element\n\n  The event callback, use audioRef.current (which is one of the key of the audio object) and\n  calls a pre-existing function on audio called play();\n  audioRef.current.play();\n */\n\n\n  // ####################################\n  // ERROR: CONTROLLED AND UNCONTROLLED\n  // ####################################\n\n  /* \n    error: a component is changing an uncontrolled input of index.js type range to be controlled.\n    Input elements should not switch from uncontrolled to controlled (or vice versa).\n\n    Uncontrolled means that our input value is not associated to a state, so when the data changes\n    associated to a state the input is still asociated to the input itself and not the react state \n    input. Once you associate the input value to the state, the component becomes controlled.\n\n    1. uncontrolled component: input that has nothing to do with a state\n    2. controlled component: value of the input is associated to  \n\n    we got the error because, that mess up with the states:\n    currentTime: 0,\n    duration: 0,\n\n    was set to null:\n    currentTime: null,\n    duration: null,\n  */\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { \n  faPlay,\n  faAngleLeft,\n  faAngleRight,\n  faPause,\n} from '@fortawesome/free-solid-svg-icons'\n\nconst Player = ({\n  isPlaying,\n  setisPlaying,\n  audioRef,\n  setsongInfo,\n  songInfo,\n  songs,\n  currentSong,\n  setcurrentSong,\n  setSongs,\n}) => {\n  // Ref,  it is moved to App. so we can use it to LibrarySong.js when you click the song there, it plays\n  // const audioRef = useRef(null);\n\n  // state I am gonna use only here: timing, moved to the app\n  /*\n    const [songInfo, setsongInfo] = useState({\n      currentTime: 0,\n      duration: 0,\n    });\n   */\n\n  /*\n    // REMOVED IT BECAUSE IT IS DOUBLE ON THE LIBRARYSONG\n    // UseEffect\n    // when you skip song also the library song gets updated\n    useEffect(() => {\n      const newSongs = songs.map((song) => {\n        if (currentSong.id === song.id) {\n          return {\n            ...song,\n            active: true,\n          };\n        } else {\n          return {\n            ...song,\n            active: false,\n          };\n        }\n      });\n      setSongs(newSongs);\n    }, [currentSong]);\n    // run this function all the time the current song is updated.\n    // basically when the current song changes, the status is active, and active status = hover LibrarySong\n */\n  const activeLibraryHandler = (nextPrev) => {\n    const newSongs = songs.map((song) => {\n      if (currentSong.id === nextPrev.id) {\n        return {\n        ...song,\n        active: true,\n        };\n      } else {\n        return {\n        ...song,\n        active: false,\n        };\n      }\n    });\n    setSongs(newSongs)\n  }\n  // Event Handlers\n  const playSongHandler = () => {\n    console.log(audioRef);\n    if (isPlaying) {\n      audioRef.current.pause();\n      setisPlaying(!isPlaying);\n    } else {\n      audioRef.current.play();\n      setisPlaying(!isPlaying);\n    }\n  };\n\n  // this is connected to the onTimeUpdate event. Which let us update values in real time\n  // this is connected to onLoadedMetadata, when the pages loads the info updated\n  // moved to the App\n  /*   const timeUpdateHandler = (e) => {\n    // from this event we can extract: the current time we are in the song and also the song duration\n    console.log(e);\n    const currentTime = e.target.currentTime;\n    const duration = e.target.duration;\n    console.log(currentTime, duration);\n    setsongInfo({...songInfo, currentTime: currentTime, duration: duration })\n  } */\n\n  // onChange is the event for this callback to move the input range\n  const dragHandler = (e) => {\n    audioRef.current.currentTime = e.target.value;\n    console.log(e.target.value);\n    setsongInfo({ ...songInfo, currentTime: e.target.value });\n  };\n  // function for formatting the time, using a stackOverflow formatting\n  function formatTime(time) {\n    return (\n      Math.floor(time / 60) + \":\" + (\"0\" + Math.floor(time % 60)).slice(-2)\n    );\n  }\n\n  const skipTrackHandler = async (direction) => {\n    // get the index of the current song\n    let currentIndex = songs.findIndex((song) => song.id === currentSong.id);\n    // if the class is equal to skip-forward the change the current song, using index +1\n    // but to prevent the last song to skip to nothing we need to add the \"modules\" %\n    // if 8 % 8 is equal to 0, 0 will be our index, so it starts again from the beginning\n    /* \n      if 2 % 8 is equal to 2, 2 will be the index. \n      It's really supper easy to figure out the results of modulo when the first number is smaller. \n      The result is always equal the the first (smaller) number.\n      Because the second number is larger, it 'goes into' the first number zero times and the remainder \n      is the entirety of this first number.\n\n      if you wanna go back, and the index is 0 you cannot go index -1. Because index -1 does not exist.\n      so we need to make a ternary where if the current index is 0 you take the song.length -1\n      and get index 7. If you are not at current index 9 you can just go back currentIndex - 1\n      we need to return it either one of the two ifs and update the \n\n    */\n    if (direction === \"skip-forward\") {\n     await setcurrentSong(songs[(currentIndex + 1) % songs.length]);\n     activeLibraryHandler(songs[(currentIndex + 1) % songs.length]);\n    } else if (direction === \"skip-back\") {\n      await setcurrentSong(songs[currentIndex - 1] || songs[songs.length - 1]);\n      activeLibraryHandler(songs[currentIndex - 1] || songs[songs.length - 1]);\n    }\n    // this line waits for the songs to load before we can actually play them\n    if (isPlaying) {\n      audioRef.current.play();\n    }\n  };\n  // const trackAnim = {\n  //   transform: `translateX(${songInfo.animationPertantage}%)`,\n  // };\n  return (\n    <div className=\"player-container\">\n      <div className=\"time-control\">\n        <p>{formatTime(songInfo.currentTime)}</p>\n        <div \n          style={{ \n            background: `linear-gradient(to right, ${currentSong.color[0]},${currentSong.color[1]})`,\n          }} \n          className=\"track\"\n          >\n          <input\n            type=\"range\"\n            value={songInfo.currentTime}\n            min={0}\n            max={songInfo.duration || 0}\n            onChange={dragHandler}\n          />\n          <div  className=\"animate-track\"></div>\n        </div>\n        <p>{songInfo.duration ? formatTime(songInfo.duration) : \"0:00\"}</p>\n      </div>\n\n      <div className=\"player-control\">\n        <FontAwesomeIcon\n          onClick={() => skipTrackHandler(\"skip-back\")}\n          className=\"skip-back\"\n          size=\"2x\"\n          icon={faAngleLeft}\n        />\n        <FontAwesomeIcon\n          onClick={playSongHandler}\n          className=\"play\"\n          size=\"2x\"\n          icon={isPlaying ? faPause : faPlay}\n        />\n        <FontAwesomeIcon\n          onClick={() => skipTrackHandler(\"skip-forward\")}\n          className=\"skip-forward\"\n          size=\"2x\"\n          icon={faAngleRight}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Player;"]},"metadata":{},"sourceType":"module"}